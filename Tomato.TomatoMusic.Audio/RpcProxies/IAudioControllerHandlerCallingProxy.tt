<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Reflection" #>
<#@ assembly name="$(TargetDir)Tomato.TomatoMusic.Core.dll" #>
<#@ output extension=".cs" #>
<# var ifaceType = typeof(Tomato.TomatoMusic.Core.IAudioControllerHandler); #>
<# var serverClassName = "IAudioControllerHandlerRpcCallingProxy"; #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using Tomato.TomatoMusic.RpcPackets.IAudioControllerHandler;

namespace Tomato.TomatoMusic.RpcCallingProxies
{
<#
var builder = new CallingProxyBuilder(ifaceType);
builder.Build();
#>
	sealed class <#= serverClassName #> : <#= ifaceType.FullName #>, global::Tomato.Rpc.Core.IPacketReceiver
	{
		private readonly global::Tomato.Rpc.Core.IPacketSender _packetSender;

		public <#= serverClassName #>(global::Tomato.Rpc.Core.IPacketSender packetSender)
		{
			_packetSender = packetSender;
		}

		void global::Tomato.Rpc.Core.IPacketReceiver.OnReceive(object packet)
		{
		}

<# foreach(var method in builder.PacketMethodPairs)
{
#>
		public void <#= method.MethodName #>(<#= string.Join(", ", method.Arguments.Select(o => o.Type + " " + o.Name)) #>)
		{
			var packet = new <#= method.PacketType #>
			{
<# foreach(var arg in method.Arguments)
{
#>
				Arg<#= arg.Index #> = <#= arg.Name #>,
<#
}
#>
			};
			_packetSender.Send(packet);
		}

<#
}
#>
	}
}

<#+
class PacketMethodPair
{
	public string MethodName;
    public string PacketType;
	public List<MethodArgument> Arguments;
}

class MethodArgument
{
	public string Type;
	public int Index;
	public string Name;
}

static string EscapeMethod(MethodInfo method)
{
	return Uri.EscapeDataString(method.ToString()).Replace("%", "_").Replace(".", "_");
}

static string ToCSharpTypeName(Type type)
{
	if(type.IsConstructedGenericType)
	{
		StringBuilder sb = new StringBuilder();
		var defName = type.GetGenericTypeDefinition().FullName;
		sb.Append(defName.Substring(0, defName.IndexOf('`')));
		sb.Append('<');
		sb.Append(string.Join(", ", type.GenericTypeArguments.Select(o => ToCSharpTypeName(o))));
		sb.Append('>');
		return sb.ToString();
	}
	return type.FullName;
}

class CallingProxyBuilder
{
	private readonly Type _serviceType;

	public List<PacketMethodPair> PacketMethodPairs = new List<PacketMethodPair>();
	
    public CallingProxyBuilder(Type serviceType)
    {
        if (!serviceType.GetTypeInfo().IsInterface)
            throw new ArgumentException("Must be a interface type.", "serviceType");
        _serviceType = serviceType;
    }

	public void Build()
	{
        foreach (var method in from m in _serviceType.GetRuntimeMethods()
                               where m.ReturnType == typeof(void)
                               select m)
        {
            DefinePacketMethodPair(method);
        }
	}

    private void DefinePacketMethodPair(MethodInfo method)
    {
		var arguments = new List<MethodArgument>();
		var @params = method.GetParameters();
        for (int i = 0; i < @params.Length; i++)
        {
			var paramType = @params[i].ParameterType;
			arguments.Add(new MethodArgument
			{
				Type = ToCSharpTypeName(paramType),
				Index = i,
				Name = @params[i].Name
			});
		}
		PacketMethodPairs.Add(new PacketMethodPair
		{
			MethodName = method.Name,
			PacketType = EscapeMethod(method),
			Arguments = arguments
		});
    }
}
#>