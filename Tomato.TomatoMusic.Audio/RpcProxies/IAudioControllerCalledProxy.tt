<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Reflection" #>
<#@ assembly name="$(TargetDir)Tomato.TomatoMusic.Core.dll" #>
<#@ output extension=".cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using Tomato.TomatoMusic.RpcPackets.IAudioController;

namespace Tomato.TomatoMusic.RpcCalledProxies
{
<# var ifaceType = typeof(Tomato.TomatoMusic.Core.IAudioController); #>
<# var serverClassName = "IAudioControllerRpcCalledProxy"; #>
<#
var builder = new CalledProxyBuilder(ifaceType);
builder.Build();
#>
	sealed class <#= serverClassName #> : global::Tomato.Rpc.Core.IPacketReceiver
	{
		private readonly <#= ifaceType.FullName #> _impl;
		private readonly Dictionary<Type, Action<object>> _packetMethodMap;

		public <#= serverClassName #>(<#= ifaceType.FullName #> impl)
		{
			_impl = impl;
			_packetMethodMap = new Dictionary<Type, Action<object>>
			{
<# foreach(var method in builder.PacketMethodPairs)
{
#>
				{ typeof(<#= method.PacketType #>), Process<#= method.PacketType #> },
<#
}
#>
			};
		}

		public void OnReceive(object packet)
		{
			Action<object> processor;
			if(_packetMethodMap.TryGetValue(packet.GetType(), out processor))
				processor(packet);
		}

<# foreach(var method in builder.PacketMethodPairs)
{
#>
		void Process<#= method.PacketType #>(object packetObj)
		{
			var packet = (<#= method.PacketType #>)packetObj;
			_impl.<#= method.MethodName #>(<#= string.Join(", ", Enumerable.Range(0, method.ArgsCount).Select(o => "packet.Arg" + o)) #>);
		}

<#
}
#>
	}
}

<#+
class PacketMethodPair
{
	public string MethodName;
    public string PacketType;
	public int ArgsCount;
}

static string EscapeMethod(MethodInfo method)
{
	return Uri.EscapeDataString(method.ToString()).Replace("%", "_").Replace(".", "_");
}

static string ToCSharpTypeName(Type type)
{
	if(type.IsConstructedGenericType)
	{
		StringBuilder sb = new StringBuilder();
		var defName = type.GetGenericTypeDefinition().FullName;
		sb.Append(defName.Substring(0, defName.IndexOf('`')));
		sb.Append('<');
		sb.Append(string.Join(", ", type.GenericTypeArguments.Select(o => ToCSharpTypeName(o))));
		sb.Append('>');
		return sb.ToString();
	}
	return type.FullName;
}

class CalledProxyBuilder
{
	private readonly Type _serviceType;

	public List<PacketMethodPair> PacketMethodPairs = new List<PacketMethodPair>();
	
    public CalledProxyBuilder(Type serviceType)
    {
        if (!serviceType.GetTypeInfo().IsInterface)
            throw new ArgumentException("Must be a interface type.", "serviceType");
        _serviceType = serviceType;
    }

	public void Build()
	{
        foreach (var method in from m in _serviceType.GetRuntimeMethods()
                               where m.ReturnType == typeof(void)
                               select m)
        {
            DefinePacketMethodPair(method);
        }
	}

    private void DefinePacketMethodPair(MethodInfo method)
    {
		PacketMethodPairs.Add(new PacketMethodPair
		{
			MethodName = method.Name,
			PacketType = EscapeMethod(method),
			ArgsCount = method.GetParameters().Length
		});
    }
}
#>